实现结果及总结如下：
第一种方式：

第二种方式：

第三种方式：
1）优化前

2）优化后


总结:
性能：第一种和第二种在数据量大的场景应该不是最优的，因为在百万级别以上的遍历是很耗时间，多线程去并发也很难弥补数据量大的遍历耗时， 比如第一种的需先排序遍历的耗时；第二种内存空间占用会过大，在数据大场景下根本不会给空间多资源消耗；第三种是个人认为最优的，因为数组转map存储结构，不像转字符类型需遍历，也需先排序顺序，直接通过遍历一遍，边遍历边key判断累加频次，最后从遍历map取出最高的频次即可，步骤简单耗时小，实现思维也易理解，毕竟map下ConcurrentHash容器早就应用并发提速与安全保证种，所以在真实业务场景应用最可行了。
推荐：第三种
收获：动手和思维的转变
